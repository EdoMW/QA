---
title: "204166524"
author: '204166524'
date: "19 7 2020"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# install.packages("IQCC")
library(IQCC)
```

## Q1

```{r, echo=TRUE}
paste("1.1")
seed <- 204166524
set.seed(seed)
x <- rnorm(100)
```

```{r, echo=TRUE}
paste("1.2")
paste(" The first observation in the data is: ", x[1])
```

```{r, echo=TRUE}
paste("1.3")
mu <- mean(x)
USL <- 2
LSL <- -2
range1 <- max(x)- min(x)
d2 <- d2(length(x))
paste("d2 : ", d2)
sigma <- (range1)/d2
Cpu <- (USL-mu)/(3*sigma)
Cpl <- (mu-LSL)/(3*sigma)
paste("Mean : ",mu )
paste("Range : ",range1 )
paste("Cpu :", Cpu)
paste("Cpl :", Cpl)
Cpk <- min(c(Cpu,Cpl))
paste ("Cpk : " , Cpk)

```

```{r, echo=TRUE}
paste("1.4")
Cp <- ((USL-LSL)/(6*sigma))
paste("Cp : ",Cp)
n <- 100
alpha <- 0.05
L_Limit <- Cp*sqrt(qchisq ( ( (alpha)/2) ,(n-1) )/ (n-1))
U_Limit <- Cp*sqrt(qchisq ( ( (1-(alpha) )/ 2), (n-1))/ (n-1))


paste( "The interval estimation for Capability Indexes is: [", L_Limit, ",",U_Limit , "]" )

```

```{r, echo=TRUE}
paste("2.1")
seed <- 203740246
set.seed(seed)
periods.1 <- 100
phase.1 <- rnorm(periods.1)
mu0 <- mean(phase.1)
sd0 <- sd(phase.1)

```

```{r, echo=TRUE}
paste("2.2")
L <- 3
CL <- mu0
n <- length(periods.1)
UCL <- CL+L*sd0/sqrt(1) # double check~!!!!!!!!
LCL <- CL-L*sd0/sqrt(1) #  double check~!!!!!!!!
paste("The control limits are:")
paste("LCL :", LCL)
paste("UCL :", UCL)

```

```{r, echo=TRUE}
paste("2.3")
paste("From the code above, the actual expectancy is 0 and the standard deviation is 1.
       It can be inferred from the forth line of the attached code,
       when we sample 100 random numbers from standard normal distribution")

```

```{r, echo=TRUE}
paste("2.4")
seed <- 204166524
set.seed(seed)
periods.2 <- 1e4
phase.2 <- rnorm(periods.2) # generate another 10,000 samples

```

```{r, echo=TRUE}
paste("2.5")
alpha <- 2700/1e6
ARL0 <- 1/alpha

l <- c(0)
gap <- 0
for (i in 1:length(phase.2)){
  gap <- gap+1
  if (phase.2[i] > UCL || phase.2[i] < LCL) {
    l<-c(l,gap)
    gap <- 0 
  }
}

l[-c(1)] # remove the first elemnt of the list 
simulated_ARL0 <- mean(l)
paste("simulated_ARL0 :", simulated_ARL0)
paste("We can see that the ARL0 is smaller in the simulation I made, which means more false alerms are produced.")

```


```{r, echo=TRUE}
paste("3.1")
seed <- 204166524
set.seed(seed)
periods <- 100
p <- 5
alpha_star <- 0.1
alpha <- 1 - (1 - alpha_star)^(1/p)
L <- -qnorm(alpha/2)
data <- matrix(rnorm(periods*p), nrow = periods)
Phase1_mat<- data[1:50,] # first 50 rows of the data for phase 1




CL3 <-  empty_vec <- rep(NA, 5)
SD3 <- rep(NA, 5)
UCL3 <- rep(NA, 5)
LCL3 <- rep(NA, 5)

CL33 <-colMeans(Phase1_mat)
SD33 <- apply(Phase1_mat, 2, sd)

for (i in 1:5){
  temp_cl3 <- mean(Phase1_mat[1:50,i])
  temp_sd3 <- sd(Phase1_mat[1:50,i])
  
  CL3[i] <- temp_cl3
  SD3[i] <- temp_sd3
  
  UCL3[i] <- CL3[i]+L*SD3[i]/sqrt(1) # emprical distbition
  LCL3[i] <- CL3[i]-L*SD3[i]/sqrt(1) # emprical distbition
}
for (p in 1:5){
paste("p) LCL :", LCL3[p], "UCL :", UCL3[p]) # check why not printing ~!!!!
}
```  
  
  
```{r, echo=TRUE}
paste("3.2")

x <- Phase1_mat
n <- nrow(Phase1_mat)
mu0 <- CL3
sigma0 <- cor(Phase1_mat) # cov matrix
sigma0.inv <-  sigma0.inv <- solve(sigma0) # inverse cov matrix
valid <- sigma0 %*% sigma0.inv # sanity check

prmatrix(sigma0.inv, rowlab =, collab =,
         quote = TRUE, right = FALSE, na.print = NULL)

t_squre <- n * (x-mu0) %*% sigma0.inv %*% t((x-mu0))
UCL_3.2 <- qchisq ( ( (1-(alpha) )), (5))

paste("Hottelingâ€™s UCL: ", UCL_3.2)

paste("when alpha is set to 10%, the ARL0 is 1/alpha :", 1/0.1)

```




```{r, echo=TRUE}
paste("3.3")

Phase2_vec_2 <- data[51:100,2]
n <- nrow(Phase2_vec_2)
sd_3.2 <- SD3[2] 

Rule1 <- function(x, sd){
     result <- FALSE
     if( sum(x > CL3[2]+3*sd)>0){
       result <- TRUE}
     if( sum(x < CL3[2]-3*sd)>0){
       result <- TRUE}
     return(result)
    }
 

Rule2 <- function(x, sd){
    result <- FALSE
      if( (sum(x > CL3[2]+2*sd && x < CL3[2]+3*sd )) > 1) # although the "and" is unnecessary because the first rule is always checked first
        result = TRUE
      if( (sum(x < CL3[2]-2*sd && x > CL3[2]-3*sd ))> 1 ) # although the "and" is unnecessary because the first rule is always checked first
        result = TRUE
      return(result)
     }



Rule3 <- function(x, sd){
    result <- FALSE
     if( (sum(x > CL3[2]+ 1*sd))>=4)
       result = TRUE
     if( (sum(x < CL3[2]- 1*sd))>=4)
       result = TRUE
     return(result)
     }


Rule4 <- function(x,sd){
    result <- FALSE
     if( sum(x > CL3[2]) >=8) result <- TRUE
     if( sum(x < -CL3[2])>=8) result <- TRUE
     return(result)
}

sum <- 0
for(i in 1:50){
    x<-c(Phase2_vec_2[i])
    if(Rule1(x,sd_3.2)) {
      sum <- sum+1 }
    
    if (i >= 3) {
    x<-c(Phase2_vec_2[i],Phase2_vec_2[i-1],Phase2_vec_2[i-2])
      if(Rule2(x,sd_3.2)==TRUE) {
        sum <- sum+1 }}
    
    if (i >= 5) {
    x<-c(Phase2_vec_2[i],Phase2_vec_2[i-1],Phase2_vec_2[i-2],Phase2_vec_2[i-3],Phase2_vec_2[i-4])
      if(Rule3(x,sd_3.2)==TRUE) {
        sum <- sum+1 }}
    
    if (i >= 8) {
    x<-c(Phase2_vec_2[i],Phase2_vec_2[i-1],Phase2_vec_2[i-2],Phase2_vec_2[i-3],Phase2_vec_2[i-4],Phase2_vec_2[i-5],Phase2_vec_2[i-6],Phase2_vec_2[i-7])
      if(Rule4(x,sd_3.2)==TRUE) {
        sum <- sum+1 }}
    if (sum > 0){
      print(i)
      break}
}



```




```{r, echo=TRUE}
bb <- c(3,3,2)


re <- if(sum(bb > 2 ) >1) re = TRUE
print(re)

```





```{r, echo=TRUE}
paste("5.1")
seed <- 204166524
set.seed(seed)
n <- 100
p <- 10
X <- matrix(rnorm(n*p), nrow = n)
mod <- 2^15
beta <- rep((seed %/% mod)/mod, p)
y <- exp(X %*% beta)

```


